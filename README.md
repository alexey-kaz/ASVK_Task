# Распределение вычислительной нагрузки

# в многопроцессорной вычислительной системе

# 1 Постановка задачи

```
Имеется многопроцессорная вычислительная система (ВС) с одинаковыми узлами-процессорами,
соединенными сетью. Задан набор программ, которые должны выполняться на этой ВС. Каждая
программа выполняется на одном процессоре; допустимо выполнение на одном и том же
процессоре нескольких программ. Между некоторыми программами происходит обмен данными с
фиксированной скоростью. Такая архитектура используется в управляющих ВС, например, в системах
авионики или автоматизации производства.
```
```
Каждая программа создает фиксированную нагрузку на процессор. Для каждого процессора
задана верхняя граница допустимой нагрузки на него.
Программы, выполняющиеся на разных процессорах, обмениваются данными через сеть; при
этом создается нагрузка на сеть, измеряемая в Кбайт/с. Программы, выполняющимися на одном и
том же процессоре, обмениваются данными через локальную память процессора; такой обмен не
создает нагрузку на сеть.
Чтобы минимизировать задержки при передаче данных через сеть, а также повысить
масштабируемость системы, программы распределяют по процессорам так, чтобы нагрузка на сеть
была минимальной.
Задано:
- число процессоров в ВС;
- для каждого процессора – верхняя граница нагрузки (в %, не более 100);
- число программ;
- для каждой программы: нагрузка на процессор (в %, не более 100);
- перечень пар программ, между которыми идет обмен данными;
- для каждой такой пары программ: интенсивность обмен данными (Кбайт/с).
```

```
Требуется: распределить все программы по процессорам так, чтобы минимизировать нагрузку
на сеть, и при этом не нарушить ограничения по нагрузке на процессоры.
Решение задачи представляется в виде вектора (его размер равен числу программ), в котором
для каждой программы указан номер процессора, на который она распределена.
Для упрощения алгоритмов решения задачи и формирования наборов входных данных для
исследования алгоритмов, на входные данные накладываются следующие дополнительные
ограничения:
- верхняя граница нагрузки на процессор может принимать значения 60, 80, 100 (%);
- создаваемая программой нагрузка на процессор может принимать значения 5, 10, 20 (%);
- интенсивность обмена данными между программами может быть равной 0 (нет обмена),
10, 50, 100 (Кбайт/с).
```
# 2 Алгоритм случайного поиска с сужением области

# для распределения программ по процессорам

```
Данный алгоритм итеративно случайным образом генерирует решение задачи и проверяет,
лучше ли оно по значению целевой функции (т.е. нагрузки на сеть), чем наилучшее из ранее
найденных корректных (удовлетворяющих ограничениям) решений. Если лучше, то проверяется
корректность сгенерированного решения; в случае корректности, это решение становится новым
наилучшим.
Схема выполнения базового алгоритма следующая:
1) рассчитать теоретическую максимальную нагрузку на сеть (для случая, когда весь обмен
данными идет через сеть);
2) установить текущее наилучшее значение целевой функции в рассчитанное на шаге 1 значение;
3) случайным образом сформировать решение задачи;
4) если сформированное решение не лучше, чем ранее найденное, перейти к шагу 3
5) если вектор – некорректное решение (нарушает ограничения по нагрузке на процессоры), перейти к
шагу 3;
// на шаге 6 имеем корректное решение, лучшее чем ранее найденное
6) обновить текущее наилучшее решение и текущее наилучшее значение целевой функции
7) перейти к шагу 3.
Завершение алгоритма происходит при нахождении корректного решения с нулевым значением, либо когда за
1000 попыток подряд не удалось улучшить значение. В случае если при выполнении алгоритма не удалось найти 
ни одного корректного решения, результатом работы алгоритма должен быть массив,
содержащий только значения (-1).

Параллельный алгоритм : алгоритм работает в виде несколько параллельно работающих «потоков», каждый из 
которых выполняет те же действия, что и базовый алгоритм. Потоки обновляют единое (общее для них) 
наилучшее решение и наилучшее значение целевой функции.
```
# 3 Формат входных данных

```
Набор входных данных (см. пункт «Задано» постановки задачи) задается в файле. Формат файла
должен быть основан на XML. Конкретную структуру файла (элементы XML, их атрибуты) необходимо
разработать.
```
# 4 Формат выходных данных

```
В стандартный вывод необходимо вывести:
В случае успеха:
1) строку «success»;
2) число итераций алгоритма;
3) элементы найденного решения с разделителем-пробелом;
4) значение загрузки сети на найденном решении.
Текст по каждому из пунктов 1, 2, 3 выводить на отдельной строке.
В случае неуспеха:
1) строку «failure»;
2) число итераций алгоритма.
```
# 5 Задания и система оценки

```
ASVK_MAIN_TASK:
1) реализовать базовый алгоритм решения задачи в виде программы на языке С++ или
Python;
2) проверить его работу на наборах данных с 4, 8, 16 процессорами; средним числом
программ на процессор (число_программ / число_процессоров) не менее 8; средней
загрузкой процессора не менее 50%; каждая программа ведет обмен данными не менее
чем с двумя другими программами; в каждом наборе входных данных должны
присутствовать все указанные в Постановке задачи варианты верхней границы нагрузки
на процессор, загрузки процессора, интенсивности обмена данными;
(наборы данных должны быть присланы вместе с программой)
3) написать инструкцию к программе:
-- как собирать и запускать программу;
-- описание формата входного файла.

ASVK_EXTRA_TASK:
1) реализовать параллельный алгоритм в виде многопоточной программы на том же языке,
что и базовый алгоритм;
2) исследовать, на сколько (в % относительно базового алгоритма) уменьшается время
выполнения программы при увеличении числа потоков (на наборах данных с 16
процессорами);
3) оформить результат исследования в виде диаграммы.

ASVK_DOCKER_TASK:
1) реализовать решение задачи в виде клиент-серверного приложения с использованием
docker:
- клиент и сервер выполняются в отдельных docker-контейнерах;
- клиент и сервер взаимодействуют посредством XML-RPC;
- у клиента имеется несколько комплектов входных данных;
- клиент передает серверу комплект входных данных и ожидает ответа от сервера;
- сервер выполняет решение задачи, передает результат клиенту и ожидает
следующего комплекта входных данных;
- после получения ответа, клиент передает серверу очередной комплект входных
данных.
2) выложить docker-образы на Docker Hub
3) написать инструкцию, как продемонстрировать решение на сайте https://labs.play-with-docker.com/
